{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 100, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/7400/Desktop/my-project/lost-found-app/lib/prisma.js"],"sourcesContent":["import { PrismaClient } from '@prisma/client';\r\n\r\n// Prevent multiple instances of Prisma Client in development\r\nconst globalForPrisma = global;\r\n\r\nexport const prisma = globalForPrisma.prisma || new PrismaClient({\r\n  log: process.env.NODE_ENV === 'development' ? ['query', 'error', 'warn'] : ['error'],\r\n});\r\n\r\nif (process.env.NODE_ENV !== 'production') {\r\n  globalForPrisma.prisma = prisma;\r\n}"],"names":[],"mappings":";;;;AAAA;;AAEA,6DAA6D;AAC7D,MAAM;AAEC,MAAM,SAAS,gBAAgB,MAAM,IAAI,IAAI,6IAAY,CAAC;IAC/D,KAAK,uCAAyC;QAAC;QAAS;QAAS;KAAO,GAAG;AAC7E;AAEA,wCAA2C;IACzC,gBAAgB,MAAM,GAAG;AAC3B","debugId":null}},
    {"offset": {"line": 134, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/7400/Desktop/my-project/lost-found-app/lib/auth.js"],"sourcesContent":["import bcrypt from 'bcryptjs';\r\nimport jwt from 'jsonwebtoken';\r\nimport { cookies } from 'next/headers';\r\n\r\nconst JWT_SECRET = process.env.JWT_SECRET || 'your-secret-key-change-in-production';\r\n\r\nif (!process.env.JWT_SECRET) {\r\n  console.warn('⚠️ WARNING: JWT_SECRET is not set in environment variables!');\r\n}\r\n\r\n// ============================================\r\n// PASSWORD HASHING\r\n// ============================================\r\n\r\n/**\r\n * Hash a password using bcrypt\r\n * @param {string} password - Plain text password\r\n * @returns {Promise<string>} Hashed password\r\n */\r\nexport async function hashPassword(password) {\r\n  return await bcrypt.hash(password, 12);\r\n}\r\n\r\n/**\r\n * Verify a password against a hash\r\n * @param {string} password - Plain text password\r\n * @param {string} hashedPassword - Hashed password from database\r\n * @returns {Promise<boolean>} True if password matches\r\n */\r\nexport async function verifyPassword(password, hashedPassword) {\r\n  return await bcrypt.compare(password, hashedPassword);\r\n}\r\n\r\n// ============================================\r\n// JWT TOKEN MANAGEMENT\r\n// ============================================\r\n\r\n/**\r\n * Generate JWT token for a user\r\n * @param {number} userId - User ID\r\n * @param {string} email - User email\r\n * @returns {string} JWT token\r\n */\r\nexport function generateToken(userId, email) {\r\n  return jwt.sign(\r\n    { \r\n      userId, \r\n      email,\r\n      iat: Math.floor(Date.now() / 1000)\r\n    },\r\n    JWT_SECRET,\r\n    { expiresIn: '7d' } // Token expires in 7 days\r\n  );\r\n}\r\n\r\n/**\r\n * Verify and decode JWT token\r\n * @param {string} token - JWT token\r\n * @returns {object|null} Decoded token or null if invalid\r\n */\r\nexport function verifyToken(token) {\r\n  try {\r\n    return jwt.verify(token, JWT_SECRET);\r\n  } catch (error) {\r\n    console.error('Token verification failed:', error.message);\r\n    return null;\r\n  }\r\n}\r\n\r\n// ============================================\r\n// REQUEST HELPERS\r\n// ============================================\r\n\r\n/**\r\n * Get user from request cookies (Server Component)\r\n * @returns {Promise<object|null>} User data or null\r\n */\r\nexport async function getUserFromCookies() {\r\n  const cookieStore = await cookies();\r\n  const token = cookieStore.get('token')?.value;\r\n  \r\n  if (!token) {\r\n    return null;\r\n  }\r\n  \r\n  return verifyToken(token);\r\n}\r\n\r\n/**\r\n * Require authentication (throw error if not authenticated)\r\n * @returns {Promise<object>} User data\r\n * @throws {Error} If not authenticated\r\n */\r\nexport async function requireAuth() {\r\n  const user = await getUserFromCookies();\r\n  \r\n  if (!user) {\r\n    throw new Error('Authentication required');\r\n  }\r\n  \r\n  return user;\r\n}\r\n\r\n// ============================================\r\n// VALIDATION\r\n// ============================================\r\n\r\n/**\r\n * Validate email format\r\n * @param {string} email - Email to validate\r\n * @returns {boolean} True if valid\r\n */\r\nexport function isValidEmail(email) {\r\n  const emailRegex = /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/;\r\n  return emailRegex.test(email);\r\n}\r\n\r\n/**\r\n * Validate password strength\r\n * @param {string} password - Password to validate\r\n * @returns {object} { valid: boolean, errors: string[] }\r\n */\r\nexport function validatePassword(password) {\r\n  const errors = [];\r\n  \r\n  if (password.length < 8) {\r\n    errors.push('Password must be at least 8 characters long');\r\n  }\r\n  \r\n  if (!/[A-Z]/.test(password)) {\r\n    errors.push('Password must contain at least one uppercase letter');\r\n  }\r\n  \r\n  if (!/[a-z]/.test(password)) {\r\n    errors.push('Password must contain at least one lowercase letter');\r\n  }\r\n  \r\n  if (!/[0-9]/.test(password)) {\r\n    errors.push('Password must contain at least one number');\r\n  }\r\n  \r\n  return {\r\n    valid: errors.length === 0,\r\n    errors\r\n  };\r\n}"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;AAAA;AACA;AACA;;;;AAEA,MAAM,aAAa,QAAQ,GAAG,CAAC,UAAU,IAAI;AAE7C,IAAI,CAAC,QAAQ,GAAG,CAAC,UAAU,EAAE;IAC3B,QAAQ,IAAI,CAAC;AACf;AAWO,eAAe,aAAa,QAAQ;IACzC,OAAO,MAAM,kMAAM,CAAC,IAAI,CAAC,UAAU;AACrC;AAQO,eAAe,eAAe,QAAQ,EAAE,cAAc;IAC3D,OAAO,MAAM,kMAAM,CAAC,OAAO,CAAC,UAAU;AACxC;AAYO,SAAS,cAAc,MAAM,EAAE,KAAK;IACzC,OAAO,sMAAG,CAAC,IAAI,CACb;QACE;QACA;QACA,KAAK,KAAK,KAAK,CAAC,KAAK,GAAG,KAAK;IAC/B,GACA,YACA;QAAE,WAAW;IAAK,EAAE,0BAA0B;;AAElD;AAOO,SAAS,YAAY,KAAK;IAC/B,IAAI;QACF,OAAO,sMAAG,CAAC,MAAM,CAAC,OAAO;IAC3B,EAAE,OAAO,OAAO;QACd,QAAQ,KAAK,CAAC,8BAA8B,MAAM,OAAO;QACzD,OAAO;IACT;AACF;AAUO,eAAe;IACpB,MAAM,cAAc,MAAM,IAAA,gMAAO;IACjC,MAAM,QAAQ,YAAY,GAAG,CAAC,UAAU;IAExC,IAAI,CAAC,OAAO;QACV,OAAO;IACT;IAEA,OAAO,YAAY;AACrB;AAOO,eAAe;IACpB,MAAM,OAAO,MAAM;IAEnB,IAAI,CAAC,MAAM;QACT,MAAM,IAAI,MAAM;IAClB;IAEA,OAAO;AACT;AAWO,SAAS,aAAa,KAAK;IAChC,MAAM,aAAa;IACnB,OAAO,WAAW,IAAI,CAAC;AACzB;AAOO,SAAS,iBAAiB,QAAQ;IACvC,MAAM,SAAS,EAAE;IAEjB,IAAI,SAAS,MAAM,GAAG,GAAG;QACvB,OAAO,IAAI,CAAC;IACd;IAEA,IAAI,CAAC,QAAQ,IAAI,CAAC,WAAW;QAC3B,OAAO,IAAI,CAAC;IACd;IAEA,IAAI,CAAC,QAAQ,IAAI,CAAC,WAAW;QAC3B,OAAO,IAAI,CAAC;IACd;IAEA,IAAI,CAAC,QAAQ,IAAI,CAAC,WAAW;QAC3B,OAAO,IAAI,CAAC;IACd;IAEA,OAAO;QACL,OAAO,OAAO,MAAM,KAAK;QACzB;IACF;AACF","debugId":null}},
    {"offset": {"line": 228, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/7400/Desktop/my-project/lost-found-app/lib/matchingAlgorithm.ts"],"sourcesContent":["/**\r\n * Matching Algorithm for Lost & Found Items\r\n * Calculates similarity score between lost and found items\r\n */\r\n\r\nimport { prisma } from '@/lib/prisma';\r\n\r\n// ============================================\r\n// TYPES\r\n// ============================================\r\n\r\ninterface ItemData {\r\n  title: string;\r\n  category: string;\r\n  description: string;\r\n  locationLost?: string | null;\r\n  locationFound?: string | null;\r\n}\r\n\r\ninterface MatchResult {\r\n  score: number;\r\n  breakdown: {\r\n    categoryScore: number;\r\n    titleScore: number;\r\n    locationScore: number;\r\n    descriptionScore: number;\r\n  };\r\n}\r\n\r\n// ============================================\r\n// FUZZY STRING MATCHING\r\n// ============================================\r\n\r\n/**\r\n * Calculates Levenshtein distance between two strings\r\n * Returns a similarity score between 0 and 1\r\n */\r\nfunction calculateStringSimilarity(str1: string, str2: string): number {\r\n  const s1 = str1.toLowerCase().trim();\r\n  const s2 = str2.toLowerCase().trim();\r\n\r\n  if (s1 === s2) return 1;\r\n  if (s1.length === 0 || s2.length === 0) return 0;\r\n\r\n  const longer = s1.length > s2.length ? s1 : s2;\r\n  const shorter = s1.length > s2.length ? s2 : s1;\r\n\r\n  if (longer.includes(shorter)) return 0.85; // Substring match is 85% similar\r\n\r\n  const editDistance = getEditDistance(shorter, longer);\r\n  const similarity = (longer.length - editDistance) / longer.length;\r\n\r\n  return Math.max(0, similarity);\r\n}\r\n\r\n/**\r\n * Levenshtein distance algorithm for string comparison\r\n */\r\nfunction getEditDistance(s1: string, s2: string): number {\r\n  const costs: number[] = [];\r\n\r\n  for (let k = 0; k <= s1.length; k++) {\r\n    let lastValue = k;\r\n    for (let i = 0; i <= s2.length; i++) {\r\n      if (k === 0) {\r\n        costs[i] = i;\r\n      } else if (i > 0) {\r\n        let newValue = costs[i - 1];\r\n        if (s1.charAt(k - 1) !== s2.charAt(i - 1)) {\r\n          newValue = Math.min(Math.min(newValue, lastValue), costs[i]) + 1;\r\n        }\r\n        costs[i - 1] = lastValue;\r\n        lastValue = newValue;\r\n      }\r\n    }\r\n    if (k > 0) costs[s2.length] = lastValue;\r\n  }\r\n\r\n  return costs[s1.length];\r\n}\r\n\r\n// ============================================\r\n// KEYWORD MATCHING\r\n// ============================================\r\n\r\n/**\r\n * Extracts keywords from text (removes common words)\r\n */\r\nfunction extractKeywords(text: string): Set<string> {\r\n  const commonWords = new Set([\r\n    'the',\r\n    'a',\r\n    'an',\r\n    'and',\r\n    'or',\r\n    'but',\r\n    'in',\r\n    'on',\r\n    'at',\r\n    'to',\r\n    'for',\r\n    'of',\r\n    'with',\r\n    'by',\r\n    'from',\r\n    'is',\r\n    'was',\r\n    'are',\r\n    'been',\r\n    'be',\r\n    'have',\r\n    'has',\r\n    'had',\r\n    'do',\r\n    'does',\r\n    'did',\r\n    'will',\r\n    'would',\r\n    'could',\r\n    'should',\r\n    'may',\r\n    'might',\r\n    'can',\r\n    'my',\r\n    'your',\r\n    'our',\r\n    'their',\r\n  ]);\r\n\r\n  const words = text.toLowerCase().match(/\\b\\w+\\b/g) || [];\r\n  return new Set(words.filter((word) => word.length > 2 && !commonWords.has(word)));\r\n}\r\n\r\n/**\r\n * Calculate keyword overlap between two texts\r\n */\r\nfunction calculateKeywordOverlap(text1: string, text2: string): number {\r\n  const keywords1 = extractKeywords(text1);\r\n  const keywords2 = extractKeywords(text2);\r\n\r\n  if (keywords1.size === 0 || keywords2.size === 0) return 0;\r\n\r\n  let overlapCount = 0;\r\n  keywords1.forEach((keyword) => {\r\n    if (keywords2.has(keyword)) {\r\n      overlapCount++;\r\n    }\r\n  });\r\n\r\n  const totalUnique = new Set([...keywords1, ...keywords2]).size;\r\n  return overlapCount / totalUnique;\r\n}\r\n\r\n// ============================================\r\n// LOCATION MATCHING\r\n// ============================================\r\n\r\n/**\r\n * Check if two locations are similar or nearby\r\n * For now, we'll do simple string matching\r\n * In a real app, you might use geocoding/distance calculation\r\n */\r\nfunction calculateLocationSimilarity(\r\n  location1: string | null | undefined,\r\n  location2: string | null | undefined\r\n): number {\r\n  if (!location1 || !location2) return 0;\r\n\r\n  const similarity = calculateStringSimilarity(location1, location2);\r\n\r\n  // Extract city/neighborhood names for partial matching\r\n  const loc1Parts = location1.toLowerCase().split(/[,\\s]+/);\r\n  const loc2Parts = location2.toLowerCase().split(/[,\\s]+/);\r\n\r\n  let partialMatch = 0;\r\n  for (const part1 of loc1Parts) {\r\n    if (part1.length > 2 && loc2Parts.includes(part1)) {\r\n      partialMatch += 1;\r\n    }\r\n  }\r\n\r\n  // If any part matches, boost the score\r\n  if (partialMatch > 0) {\r\n    return Math.min(1, similarity + 0.2);\r\n  }\r\n\r\n  return similarity;\r\n}\r\n\r\n// ============================================\r\n// MAIN MATCHING ALGORITHM\r\n// ============================================\r\n\r\n/**\r\n * Calculate match score between a lost item and a found item\r\n *\r\n * Scoring weights:\r\n * - Category match: 0.35 (most important)\r\n * - Title/Description similarity: 0.40 (very important)\r\n * - Location similarity: 0.20 (important)\r\n * - Keyword overlap: 0.05 (bonus)\r\n */\r\nexport function calculateMatchScore(\r\n  lostItem: ItemData,\r\n  foundItem: ItemData\r\n): MatchResult {\r\n  // 1. Category matching (exact match = 1, no match = 0)\r\n  const categoryScore =\r\n    lostItem.category.toLowerCase() === foundItem.category.toLowerCase() ? 1 : 0;\r\n\r\n  // 2. Title and description similarity\r\n  const titleSimilarity = calculateStringSimilarity(lostItem.title, foundItem.title);\r\n  const descriptionSimilarity = calculateStringSimilarity(\r\n    lostItem.description,\r\n    foundItem.description\r\n  );\r\n  const titleDescriptionScore = (titleSimilarity + descriptionSimilarity) / 2;\r\n\r\n  // 3. Location similarity\r\n  const locationScore = calculateLocationSimilarity(\r\n    lostItem.locationLost || lostItem.locationFound,\r\n    foundItem.locationFound || foundItem.locationLost\r\n  );\r\n\r\n  // 4. Keyword overlap\r\n  const keywordScore = calculateKeywordOverlap(\r\n    `${lostItem.title} ${lostItem.description}`,\r\n    `${foundItem.title} ${foundItem.description}`\r\n  );\r\n\r\n  // Calculate weighted score\r\n  const finalScore =\r\n    categoryScore * 0.35 +\r\n    titleDescriptionScore * 0.4 +\r\n    locationScore * 0.2 +\r\n    keywordScore * 0.05;\r\n\r\n  return {\r\n    score: Math.round(finalScore * 100) / 100, // Round to 2 decimal places\r\n    breakdown: {\r\n      categoryScore,\r\n      titleScore: titleSimilarity,\r\n      locationScore,\r\n      descriptionScore: keywordScore,\r\n    },\r\n  };\r\n}\r\n\r\n// ============================================\r\n// MATCH CREATION & RETRIEVAL\r\n// ============================================\r\n\r\n/**\r\n * Check a newly added lost item against all found items\r\n * Create matches if score >= 0.7\r\n */\r\nexport async function checkMatchesForLostItem(lostItemId: number) {\r\n  try {\r\n    // Fetch the lost item\r\n    const lostItem = await prisma.item.findUnique({\r\n      where: { id: lostItemId },\r\n    });\r\n\r\n    if (!lostItem || lostItem.status !== 'lost') return [];\r\n\r\n    // Fetch all active found items\r\n    const foundItems = await prisma.item.findMany({\r\n      where: {\r\n        status: 'found',\r\n        itemStatus: 'active',\r\n      },\r\n    });\r\n\r\n    const matches = [];\r\n\r\n    // Check against each found item\r\n    for (const foundItem of foundItems) {\r\n      const matchResult = calculateMatchScore(\r\n        {\r\n          title: lostItem.title,\r\n          category: lostItem.category,\r\n          description: lostItem.description,\r\n          locationLost: lostItem.locationLost,\r\n          locationFound: lostItem.locationFound,\r\n        },\r\n        {\r\n          title: foundItem.title,\r\n          category: foundItem.category,\r\n          description: foundItem.description,\r\n          locationLost: foundItem.locationLost,\r\n          locationFound: foundItem.locationFound,\r\n        }\r\n      );\r\n\r\n      // Log match result for debugging\r\n      console.log(`[MATCHING DEBUG] Lost Item \"${lostItem.title}\" vs Found Item \"${foundItem.title}\"`);\r\n      console.log(`  Score: ${matchResult.score} (need 0.7)`);\r\n      console.log(`  Category: ${matchResult.breakdown.categoryScore} (${lostItem.category} vs ${foundItem.category})`);\r\n      console.log(`  Title Similarity: ${matchResult.breakdown.titleScore}`);\r\n      console.log(`  Location: ${matchResult.breakdown.locationScore}`);\r\n      console.log(`  Description/Keywords: ${matchResult.breakdown.descriptionScore}`);\r\n\r\n      // Create match if score is high enough\r\n      if (matchResult.score >= 0.7) {\r\n        try {\r\n          const match = await prisma.match.upsert({\r\n            where: {\r\n              lostItemId_foundItemId: {\r\n                lostItemId,\r\n                foundItemId: foundItem.id,\r\n              },\r\n            },\r\n            update: {\r\n              matchScore: matchResult.score,\r\n            },\r\n            create: {\r\n              lostItemId,\r\n              foundItemId: foundItem.id,\r\n              matchScore: matchResult.score,\r\n              status: 'pending',\r\n            },\r\n          });\r\n\r\n          matches.push(match);\r\n\r\n          // Create notifications for both users\r\n          await Promise.all([\r\n            // Notify lost item owner\r\n            prisma.notification.create({\r\n              data: {\r\n                userId: lostItem.userId,\r\n                type: 'match',\r\n                title: 'Potential Match Found!',\r\n                message: `A potential match for your lost item \"${lostItem.title}\" was found!`,\r\n                link: `/matches/${match.id}`,\r\n              },\r\n            }),\r\n            // Notify found item owner\r\n            prisma.notification.create({\r\n              data: {\r\n                userId: foundItem.userId,\r\n                type: 'match',\r\n                title: 'Your Found Item May Help!',\r\n                message: `Your found item \"${foundItem.title}\" may match a lost item someone is looking for!`,\r\n                link: `/matches/${match.id}`,\r\n              },\r\n            }),\r\n          ]);\r\n        } catch (err) {\r\n          console.error('Error creating match:', err);\r\n        }\r\n      }\r\n    }\r\n\r\n    return matches;\r\n  } catch (error) {\r\n    console.error('Error checking matches for lost item:', error);\r\n    throw error;\r\n  }\r\n}\r\n\r\n/**\r\n * Check a newly added found item against all lost items\r\n * Create matches if score >= 0.7\r\n */\r\nexport async function checkMatchesForFoundItem(foundItemId: number) {\r\n  try {\r\n    // Fetch the found item\r\n    const foundItem = await prisma.item.findUnique({\r\n      where: { id: foundItemId },\r\n    });\r\n\r\n    if (!foundItem || foundItem.status !== 'found') return [];\r\n\r\n    // Fetch all active lost items\r\n    const lostItems = await prisma.item.findMany({\r\n      where: {\r\n        status: 'lost',\r\n        itemStatus: 'active',\r\n      },\r\n    });\r\n\r\n    const matches = [];\r\n\r\n    // Check against each lost item\r\n    for (const lostItem of lostItems) {\r\n      const matchResult = calculateMatchScore(\r\n        {\r\n          title: lostItem.title,\r\n          category: lostItem.category,\r\n          description: lostItem.description,\r\n          locationLost: lostItem.locationLost,\r\n          locationFound: lostItem.locationFound,\r\n        },\r\n        {\r\n          title: foundItem.title,\r\n          category: foundItem.category,\r\n          description: foundItem.description,\r\n          locationLost: foundItem.locationLost,\r\n          locationFound: foundItem.locationFound,\r\n        }\r\n      );\r\n\r\n      // Log match result for debugging\r\n      console.log(`[MATCHING DEBUG] Lost Item \"${lostItem.title}\" vs Found Item \"${foundItem.title}\"`);\r\n      console.log(`  Score: ${matchResult.score} (need 0.7)`);\r\n      console.log(`  Category: ${matchResult.breakdown.categoryScore} (${lostItem.category} vs ${foundItem.category})`);\r\n      console.log(`  Title Similarity: ${matchResult.breakdown.titleScore}`);\r\n      console.log(`  Location: ${matchResult.breakdown.locationScore}`);\r\n      console.log(`  Description/Keywords: ${matchResult.breakdown.descriptionScore}`);\r\n\r\n      // Create match if score is high enough\r\n      if (matchResult.score >= 0.7) {\r\n        try {\r\n          const match = await prisma.match.upsert({\r\n            where: {\r\n              lostItemId_foundItemId: {\r\n                lostItemId: lostItem.id,\r\n                foundItemId,\r\n              },\r\n            },\r\n            update: {\r\n              matchScore: matchResult.score,\r\n            },\r\n            create: {\r\n              lostItemId: lostItem.id,\r\n              foundItemId,\r\n              matchScore: matchResult.score,\r\n              status: 'pending',\r\n            },\r\n          });\r\n\r\n          matches.push(match);\r\n\r\n          // Create notifications for both users\r\n          await Promise.all([\r\n            // Notify lost item owner\r\n            prisma.notification.create({\r\n              data: {\r\n                userId: lostItem.userId,\r\n                type: 'match',\r\n                title: 'Potential Match Found!',\r\n                message: `A potential match for your lost item \"${lostItem.title}\" was found!`,\r\n                link: `/matches/${match.id}`,\r\n              },\r\n            }),\r\n            // Notify found item owner\r\n            prisma.notification.create({\r\n              data: {\r\n                userId: foundItem.userId,\r\n                type: 'match',\r\n                title: 'Your Found Item May Help!',\r\n                message: `Your found item \"${foundItem.title}\" may match a lost item someone is looking for!`,\r\n                link: `/matches/${match.id}`,\r\n              },\r\n            }),\r\n          ]);\r\n        } catch (err) {\r\n          console.error('Error creating match:', err);\r\n        }\r\n      }\r\n    }\r\n\r\n    return matches;\r\n  } catch (error) {\r\n    console.error('Error checking matches for found item:', error);\r\n    throw error;\r\n  }\r\n}\r\n\r\n/**\r\n * Get all matches for a user (both as lost item owner and found item owner)\r\n */\r\nexport async function getUserMatches(userId: number) {\r\n  try {\r\n    const matches = await prisma.match.findMany({\r\n      where: {\r\n        OR: [\r\n          {\r\n            lostItem: {\r\n              userId,\r\n            },\r\n          },\r\n          {\r\n            foundItem: {\r\n              userId,\r\n            },\r\n          },\r\n        ],\r\n      },\r\n      include: {\r\n        lostItem: {\r\n          include: {\r\n            user: {\r\n              select: {\r\n                id: true,\r\n                name: true,\r\n                email: true,\r\n                profileImage: true,\r\n              },\r\n            },\r\n          },\r\n        },\r\n        foundItem: {\r\n          include: {\r\n            user: {\r\n              select: {\r\n                id: true,\r\n                name: true,\r\n                email: true,\r\n                profileImage: true,\r\n              },\r\n            },\r\n          },\r\n        },\r\n      },\r\n      orderBy: {\r\n        matchScore: 'desc',\r\n      },\r\n    });\r\n\r\n    return matches;\r\n  } catch (error) {\r\n    console.error('Error fetching user matches:', error);\r\n    throw error;\r\n  }\r\n}\r\n\r\n/**\r\n * Mark a match as confirmed\r\n */\r\nexport async function confirmMatch(matchId: number, notes?: string) {\r\n  try {\r\n    const match = await prisma.match.update({\r\n      where: { id: matchId },\r\n      data: {\r\n        status: 'confirmed',\r\n        notes,\r\n      },\r\n    });\r\n\r\n    return match;\r\n  } catch (error) {\r\n    console.error('Error confirming match:', error);\r\n    throw error;\r\n  }\r\n}\r\n"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 661, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/7400/Desktop/my-project/lost-found-app/src/app/api/items/route.js"],"sourcesContent":["// lib/cloudinary.js\nimport { v2 as cloudinary } from 'cloudinary';\n\ncloudinary.config({ \n  cloud_name: process.env.CLOUDINARY_CLOUD_NAME || 'dgnxydock', \n  api_key: process.env.CLOUDINARY_API_KEY || '821783795161467', \n  api_secret: process.env.CLOUDINARY_API_SECRET\n});\n\n/**\n * Upload image to Cloudinary\n * @param {string} fileData - Base64 data URI or file path\n * @param {string} folder - Cloudinary folder (e.g., 'lost-items', 'found-items')\n * @returns {Promise<Object>} Upload result with secure_url\n */\nexport async function uploadImage(fileData, folder = 'items') {\n  try {\n    const uploadResult = await cloudinary.uploader.upload(fileData, {\n      folder: folder,\n      resource_type: 'auto',\n      transformation: [\n        { width: 1000, height: 1000, crop: 'limit' }, // Limit max size\n        { quality: 'auto', fetch_format: 'auto' } // Optimize\n      ]\n    });\n\n    return {\n      url: uploadResult.secure_url,\n      publicId: uploadResult.public_id,\n      width: uploadResult.width,\n      height: uploadResult.height\n    };\n  } catch (error) {\n    console.error('Cloudinary upload error:', error);\n    throw new Error('Failed to upload image');\n  }\n}\n\n/**\n * Delete image from Cloudinary\n * @param {string} publicId - Cloudinary public_id\n */\nexport async function deleteImage(publicId) {\n  try {\n    await cloudinary.uploader.destroy(publicId);\n  } catch (error) {\n    console.error('Cloudinary delete error:', error);\n  }\n}\n\n/**\n * Get optimized image URL\n * @param {string} publicId - Cloudinary public_id\n * @param {Object} options - Transformation options\n */\nexport function getOptimizedUrl(publicId, options = {}) {\n  return cloudinary.url(publicId, {\n    fetch_format: 'auto',\n    quality: 'auto',\n    ...options\n  });\n}\n\n// ===================================================================\n// app/api/items/route.js\n// ===================================================================\n\nimport { NextResponse } from 'next/server';\nimport { prisma } from '@/lib/prisma';\nimport { getUserFromCookies } from '@/lib/auth';\nimport { checkMatchesForLostItem, checkMatchesForFoundItem } from '@/lib/matchingAlgorithm';\nimport { uploadImage } from '@/lib/cloudinary';\n\nexport async function GET(request) {\n  try {\n    const { searchParams } = new URL(request.url);\n    const status = searchParams.get('status');\n    const category = searchParams.get('category');\n    const page = parseInt(searchParams.get('page')) || 1;\n    const limit = parseInt(searchParams.get('limit')) || 10;\n\n    const skip = (page - 1) * limit;\n\n    const where = {};\n    if (status && ['lost', 'found'].includes(status)) {\n      where.status = status;\n    }\n    if (category) {\n      where.category = category;\n    }\n\n    const total = await prisma.item.count({ where });\n\n    const items = await prisma.item.findMany({\n      where,\n      skip,\n      take: limit,\n      orderBy: {\n        createdAt: 'desc'\n      },\n      include: {\n        user: {\n          select: {\n            id: true,\n            name: true,\n            email: true,\n            profileImage: true\n          }\n        }\n      }\n    });\n\n    return NextResponse.json({\n      success: true,\n      items,\n      pagination: {\n        page,\n        limit,\n        total,\n        pages: Math.ceil(total / limit)\n      }\n    });\n  } catch (error) {\n    console.error('Fetch items error:', error);\n    return NextResponse.json(\n      { error: 'Failed to fetch items' },\n      { status: 500 }\n    );\n  }\n}\n\nexport async function POST(request) {\n  try {\n    const user = await getUserFromCookies();\n    \n    if (!user) {\n      return NextResponse.json(\n        { error: 'Authentication required' },\n        { status: 401 }\n      );\n    }\n\n    const body = await request.json();\n    const {\n      title,\n      description,\n      category,\n      status,\n      itemStatus,\n      locationLost,\n      locationFound,\n      locationDetails,\n      dateLost,\n      dateFound,\n      color,\n      brand,\n      distinguishingFeatures,\n      contactInfo,\n      rewardAmount,\n      tags,\n      images // Array of base64 data URIs\n    } = body;\n\n    // Validation\n    if (!title || !title.trim()) {\n      return NextResponse.json(\n        { error: 'Title is required' },\n        { status: 400 }\n      );\n    }\n\n    if (!description || !description.trim()) {\n      return NextResponse.json(\n        { error: 'Description is required' },\n        { status: 400 }\n      );\n    }\n\n    if (!category) {\n      return NextResponse.json(\n        { error: 'Category is required' },\n        { status: 400 }\n      );\n    }\n\n    if (!status || !['lost', 'found'].includes(status)) {\n      return NextResponse.json(\n        { error: 'Invalid status' },\n        { status: 400 }\n      );\n    }\n\n    if (status === 'lost' && !locationLost) {\n      return NextResponse.json(\n        { error: 'Location where item was lost is required' },\n        { status: 400 }\n      );\n    }\n\n    if (status === 'found' && !locationFound) {\n      return NextResponse.json(\n        { error: 'Location where item was found is required' },\n        { status: 400 }\n      );\n    }\n\n    // Upload images to Cloudinary\n    let imageUrls = [];\n    if (images && Array.isArray(images) && images.length > 0) {\n      try {\n        const folder = status === 'lost' ? 'lost-items' : 'found-items';\n        const uploadPromises = images.map(img => uploadImage(img, folder));\n        const uploadResults = await Promise.all(uploadPromises);\n        imageUrls = uploadResults.map(result => result.url);\n      } catch (uploadError) {\n        console.error('Image upload error:', uploadError);\n        return NextResponse.json(\n          { error: 'Failed to upload images' },\n          { status: 500 }\n        );\n      }\n    }\n\n    // Create item in database\n    const item = await prisma.item.create({\n      data: {\n        userId: user.userId,\n        title: title.trim(),\n        description: description.trim(),\n        category,\n        status,\n        itemStatus: itemStatus || 'active',\n        locationLost: locationLost?.trim() || null,\n        locationFound: locationFound?.trim() || null,\n        locationDetails: locationDetails?.trim() || null,\n        dateLost: dateLost ? new Date(dateLost) : null,\n        dateFound: dateFound ? new Date(dateFound) : null,\n        color: color?.trim() || null,\n        brand: brand?.trim() || null,\n        distinguishingFeatures: distinguishingFeatures?.trim() || null,\n        contactInfo: contactInfo?.trim() || null,\n        rewardAmount: rewardAmount ? parseFloat(rewardAmount) : null,\n        tags: tags || [],\n        imageUrls: imageUrls\n      },\n      include: {\n        user: {\n          select: {\n            id: true,\n            name: true,\n            email: true,\n            profileImage: true\n          }\n        }\n      }\n    });\n\n    // Check for matches and create notifications\n    try {\n      if (status === 'lost') {\n        await checkMatchesForLostItem(item.id);\n      } else if (status === 'found') {\n        await checkMatchesForFoundItem(item.id);\n      }\n    } catch (err) {\n      console.error('Error checking matches:', err);\n    }\n\n    return NextResponse.json({\n      success: true,\n      message: 'Item reported successfully',\n      item\n    }, { status: 201 });\n\n  } catch (error) {\n    console.error('Create item error:', error);\n    console.error('Error details:', {\n      message: error.message,\n      code: error.code,\n      stack: error.stack\n    });\n    return NextResponse.json(\n      { error: 'Failed to create item', details: error.message },\n      { status: 500 }\n    );\n  }\n}\n\n// ===================================================================\n// app/api/upload/route.js (Optional separate upload endpoint)\n// ===================================================================\n\nexport async function POST(request) {\n  try {\n    const user = await getUserFromCookies();\n    \n    if (!user) {\n      return NextResponse.json(\n        { error: 'Authentication required' },\n        { status: 401 }\n      );\n    }\n\n    const body = await request.json();\n    const { image, folder } = body;\n\n    if (!image) {\n      return NextResponse.json(\n        { error: 'Image data is required' },\n        { status: 400 }\n      );\n    }\n\n    const result = await uploadImage(image, folder || 'items');\n\n    return NextResponse.json({\n      success: true,\n      url: result.url,\n      publicId: result.publicId\n    });\n\n  } catch (error) {\n    console.error('Upload error:', error);\n    return NextResponse.json(\n      { error: 'Failed to upload image' },\n      { status: 500 }\n    );\n  }\n}"],"names":[],"mappings":"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","debugId":null}}]
}